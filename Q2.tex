\section{Vandermonde matrix}

The code of any shared modules for question 2 is given by:
\lstinputlisting[firstnumber=1, firstline=1, lastline=125]{2_vandermonde_matrix.py}

\subsection{a}

The code used is given by:
\lstinputlisting[firstnumber=127, firstline=127, lastline=167]{2_vandermonde_matrix.py}

\lstinputlisting[firstline=1, lastline=6]{vandermonde_matrix.txt}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\linewidth]{./my_vandermonde_sol_2a.png}
    \caption{The original data points $(x,y)$ together with the constructed 19-th degree polynomial
    using the coefficients found by solving the system $Vc=y$ using the LU decomposition of the corresponding Vandermonde matrix are shown.
    It is clear that the polynomial does not go through the original data points, as it lies way above them. However, the shape of the polynomial does somewhat seem to follow the original data points.
    It might thus be the case that in particular the offset coefficient $c_0$ has a large error, causing the polynomial to be shifted this way. The lower panel shows the absolute difference between
    the polynomial and the data points. As we can see, this offset is about 400 which is very large.}
    \label{fig:2a}
\end{figure}

\subsection{b}

The code used is given by:
\lstinputlisting[firstnumber=169, firstline=169, lastline=185]{2_vandermonde_matrix.py}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\linewidth]{./my_vandermonde_sol_2b.png}
    \caption{The previous resulting polynomial from LU decomposition is shown together with the Lagrange polynomial found using Neville's algorithm with M=20. We see that the Lagrange polynomial does closely follow the original
    data points, with a small offset shown in the lower panel of about $10^{-14}$. The offset even crashes down for some x values, indicating that the Lagrange polynomial very accurately
    follows the data points. This is to be expected, as Neville's algorithm uses direct linear interpolation on the data points, and when used on the data points themselves, the result is correct up to round off and machine error.
    The method using the Vandermonde matrix, however, is a more indirect way of computing the polynomial with more intermediate calculations, which does not compute the polynomial values directly but the polynomial coefficients first.
    As a small deviation in coefficient value can make a large difference in the polynomial values, this explains why the original LU-decomposition method gives polynomial values with a much larger error than the Lagrange polynomial from Neville's algorithm.}
    \label{fig:2b}
\end{figure}





The functions are of order lower than quadratic, which is why we don't expect Brent's method
to work optimally. Therefore, we choose the linear false position method combined with bisection to overcome slow convergence in very non-linear regions.
The higher the density, the lower the temperature, which is as expected.